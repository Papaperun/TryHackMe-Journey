This room dove into race conditions in web apps â€” what they are, how to spot them, and how to exploit them. Basically, when two or more requests hit the server at the exact same time and the app doesnâ€™t handle the order properly, you can manipulate stuff like stock counts, transaction values, or (in this case) toy orders.
First thought that hit me: this is exactly what scalpers do. Not the bots themselves, but the underlying vuln that lets one person (or script) snatch up all the tickets, PS5s, graphics cards, concert seats, whatever. They hammer the â€œbuyâ€ button with concurrent requests faster than normal humans can, and the server canâ€™t keep up with proper checks. Felt like a lightbulb moment â€” Iâ€™ve hated scalpers for years, now I see the exact mechanic that makes it possible.
Second thought: if I was gonna pull this off myself (legally, in a lab obviously), my brain instantly went â€œpyautogui and just mass-click the shit out of the button.â€ Like, literally automate mouse clicks faster than the server can process. Crude, but itâ€™d work on a badly coded app. Shows how low the bar can be sometimes.
The room had us fire off concurrent requests (Burp Repeater + Turbo Intruder, I think) to drop the toy stock below zero or double-spend credits or whatever the flag needed. Watching the balance/stock flip because of timing? Powerful as hell. Heart was legitimately racing while I was doing it â€” that mix of â€œthis is coolâ€ and â€œholy shit this is how real money gets stolen.â€
Also peeked at basic mitigations â€” atomic operations, locking, rate-limiting â€” the usual â€œdonâ€™t trust client timingâ€ stuff.
Takeaway: race conditions are sneaky because they only show up under load. Most apps look fine until someone (or some bot) hammers them at once. Ties straight back to OT too â€” imagine race conditions on PLC writes or SCADA setpoints. Bad day.
Day 20 done. Felt like I leveled up on something that explains a chunk of the real world. Still buzzing a little.
Papaperun out. ğŸ„ğŸï¸ğŸ’¥
